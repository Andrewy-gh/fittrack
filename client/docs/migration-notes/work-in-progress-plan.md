Looking at your codebase and the Hey API TanStack Query plugin documentation, here's what you'd need to configure to make minimal code changes:

## Recommended Configuration

[Hey API Configuration for Minimal Changes](./config-minimal-changes.md)

## Migration Strategy for Minimal Code Changes

Based on your current code, here's what the migration would look like:

### 1. Query Options Functions

Your current manual `queryOptions` functions would be replaced by auto-generated ones. For example, instead of:

```typescript
// Your current code
export function exercisesQueryOptions(user: User) {
  return queryOptions<exercise_ExerciseResponse[], Error>({
    queryKey: ['exercises', 'list'],
    queryFn: async () => {
      // ... your logic
    },
  });
}
```

You'd get auto-generated functions like:
```typescript
// Auto-generated by Hey API
export function getExercisesOptions(parameters?: { /* auth params */ }) {
  return queryOptions({
    queryKey: [{ _id: 'getExercises', /* normalized params */ }],
    queryFn: () => ExercisesService.getExercises(parameters),
  });
}
```
### 2. Key Changes You'd Need to Make:

1. Import the generated functions instead of creating your own
2. Update your query key structure - Hey API uses normalized object-based keys instead of array-based keys
3. Handle authentication - you'd need to ensure the auth token is set before calling the generated functions

### 3. Recommended Approach for Minimal Changes:

Since you have custom authentication logic, I'd suggest this hybrid approach:

[Migration Wrapper Functions](./migration-wrapper-functions.md)

1. Zero changes to your components - they continue using the same function names
2. Automatic query key generation - Hey API handles the complex query key normalization
3. Better cache invalidation - you can use the generated query keys for precise cache management
4. Type safety - the generated functions are fully typed from your OpenAPI spec
5. Future-proof - as your API changes, regenerating will update all the types and functions

### Alternative Minimal Configuration:

If you want even fewer changes, you could configure Hey API to match your exact current naming:

```javascript
{
  name: '@tanstack/react-query',
  queryOptions: {
    name: '{{name}}QueryOptions', // matches your current naming exactly
  },
  // ... other options
}
```

This way, if your OpenAPI operation is named `getExercises`, it would generate `getExercisesQueryOptions()` which is very close to your current `exercisesQueryOptions()`. 

The main benefit of using Hey API is that you get consistent, typed query options that automatically stay in sync with your API specification, while still being able to layer your custom authentication and business logic on top.