// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSet = `-- name: CreateSet :one
INSERT INTO "set" (exercise_id, workout_id, weight, reps, set_type, user_id, exercise_order, set_order)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id
`

type CreateSetParams struct {
	ExerciseID    int32          `json:"exercise_id"`
	WorkoutID     int32          `json:"workout_id"`
	Weight        pgtype.Numeric `json:"weight"`
	Reps          int32          `json:"reps"`
	SetType       string         `json:"set_type"`
	UserID        string         `json:"user_id"`
	ExerciseOrder int32          `json:"exercise_order"`
	SetOrder      int32          `json:"set_order"`
}

func (q *Queries) CreateSet(ctx context.Context, arg CreateSetParams) (int32, error) {
	row := q.db.QueryRow(ctx, createSet,
		arg.ExerciseID,
		arg.WorkoutID,
		arg.Weight,
		arg.Reps,
		arg.SetType,
		arg.UserID,
		arg.ExerciseOrder,
		arg.SetOrder,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (user_id)
VALUES ($1)
RETURNING id
`

func (q *Queries) CreateUser(ctx context.Context, userID string) (int32, error) {
	row := q.db.QueryRow(ctx, createUser, userID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createWorkout = `-- name: CreateWorkout :one
INSERT INTO workout (date, notes, workout_focus, user_id)
VALUES ($1, $2, $3, $4)
RETURNING id
`

type CreateWorkoutParams struct {
	Date         pgtype.Timestamptz `json:"date"`
	Notes        pgtype.Text        `json:"notes"`
	WorkoutFocus pgtype.Text        `json:"workout_focus"`
	UserID       string             `json:"user_id"`
}

// INSERT queries for form submission
func (q *Queries) CreateWorkout(ctx context.Context, arg CreateWorkoutParams) (int32, error) {
	row := q.db.QueryRow(ctx, createWorkout,
		arg.Date,
		arg.Notes,
		arg.WorkoutFocus,
		arg.UserID,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deleteExercise = `-- name: DeleteExercise :exec
DELETE FROM exercise WHERE id = $1 AND user_id = $2
`

type DeleteExerciseParams struct {
	ID     int32  `json:"id"`
	UserID string `json:"user_id"`
}

func (q *Queries) DeleteExercise(ctx context.Context, arg DeleteExerciseParams) error {
	_, err := q.db.Exec(ctx, deleteExercise, arg.ID, arg.UserID)
	return err
}

const deleteSetsByWorkout = `-- name: DeleteSetsByWorkout :exec
DELETE FROM "set" 
WHERE workout_id = $1 AND user_id = $2
`

type DeleteSetsByWorkoutParams struct {
	WorkoutID int32  `json:"workout_id"`
	UserID    string `json:"user_id"`
}

func (q *Queries) DeleteSetsByWorkout(ctx context.Context, arg DeleteSetsByWorkoutParams) error {
	_, err := q.db.Exec(ctx, deleteSetsByWorkout, arg.WorkoutID, arg.UserID)
	return err
}

const deleteSetsByWorkoutAndExercise = `-- name: DeleteSetsByWorkoutAndExercise :exec
DELETE FROM "set" 
WHERE workout_id = $1 
  AND exercise_id = $2
  AND user_id = $3
`

type DeleteSetsByWorkoutAndExerciseParams struct {
	WorkoutID  int32  `json:"workout_id"`
	ExerciseID int32  `json:"exercise_id"`
	UserID     string `json:"user_id"`
}

func (q *Queries) DeleteSetsByWorkoutAndExercise(ctx context.Context, arg DeleteSetsByWorkoutAndExerciseParams) error {
	_, err := q.db.Exec(ctx, deleteSetsByWorkoutAndExercise, arg.WorkoutID, arg.ExerciseID, arg.UserID)
	return err
}

const deleteWorkout = `-- name: DeleteWorkout :exec
DELETE FROM workout 
WHERE id = $1 
  AND user_id = $2
`

type DeleteWorkoutParams struct {
	ID     int32  `json:"id"`
	UserID string `json:"user_id"`
}

func (q *Queries) DeleteWorkout(ctx context.Context, arg DeleteWorkoutParams) error {
	_, err := q.db.Exec(ctx, deleteWorkout, arg.ID, arg.UserID)
	return err
}

const getContributionData = `-- name: GetContributionData :many
SELECT
    DATE_TRUNC('day', w.date)::DATE as date,
    COUNT(s.id)::INTEGER as count,
    ARRAY_AGG(DISTINCT w.id) as workout_ids
FROM workout w
LEFT JOIN "set" s ON s.workout_id = w.id AND s.set_type = 'working'
WHERE w.user_id = $1
  AND w.date >= CURRENT_DATE - INTERVAL '52 weeks'
GROUP BY DATE_TRUNC('day', w.date)
ORDER BY date
`

type GetContributionDataRow struct {
	Date       pgtype.Date `json:"date"`
	Count      int32       `json:"count"`
	WorkoutIds interface{} `json:"workout_ids"`
}

func (q *Queries) GetContributionData(ctx context.Context, userID string) ([]GetContributionDataRow, error) {
	rows, err := q.db.Query(ctx, getContributionData, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetContributionDataRow
	for rows.Next() {
		var i GetContributionDataRow
		if err := rows.Scan(&i.Date, &i.Count, &i.WorkoutIds); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExercise = `-- name: GetExercise :one
SELECT id, name FROM exercise WHERE id = $1 AND user_id = $2
`

type GetExerciseParams struct {
	ID     int32  `json:"id"`
	UserID string `json:"user_id"`
}

type GetExerciseRow struct {
	ID   int32  `json:"id"`
	Name string `json:"name"`
}

func (q *Queries) GetExercise(ctx context.Context, arg GetExerciseParams) (GetExerciseRow, error) {
	row := q.db.QueryRow(ctx, getExercise, arg.ID, arg.UserID)
	var i GetExerciseRow
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getExerciseByName = `-- name: GetExerciseByName :one
SELECT id, name FROM exercise WHERE name = $1 AND user_id = $2
`

type GetExerciseByNameParams struct {
	Name   string `json:"name"`
	UserID string `json:"user_id"`
}

type GetExerciseByNameRow struct {
	ID   int32  `json:"id"`
	Name string `json:"name"`
}

func (q *Queries) GetExerciseByName(ctx context.Context, arg GetExerciseByNameParams) (GetExerciseByNameRow, error) {
	row := q.db.QueryRow(ctx, getExerciseByName, arg.Name, arg.UserID)
	var i GetExerciseByNameRow
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getExerciseWithSets = `-- name: GetExerciseWithSets :many
SELECT 
    s.workout_id,
    w.date as workout_date,
    w.notes as workout_notes,
    w.workout_focus as workout_focus,
    s.id as set_id,
    s.weight,
    s.reps,
    s.set_type,
    e.id as exercise_id,
    e.name as exercise_name,
    s.exercise_order,
    s.set_order,
    (COALESCE(s.weight, 0) * s.reps)::NUMERIC(10,1) as volume
FROM "set" s
JOIN exercise e ON e.id = s.exercise_id
JOIN workout w ON w.id = s.workout_id
WHERE s.exercise_id = $1 AND s.user_id = $2
ORDER BY w.date DESC, s.exercise_order, s.set_order, s.created_at, s.id
`

type GetExerciseWithSetsParams struct {
	ExerciseID int32  `json:"exercise_id"`
	UserID     string `json:"user_id"`
}

type GetExerciseWithSetsRow struct {
	WorkoutID     int32              `json:"workout_id"`
	WorkoutDate   pgtype.Timestamptz `json:"workout_date"`
	WorkoutNotes  pgtype.Text        `json:"workout_notes"`
	WorkoutFocus  pgtype.Text        `json:"workout_focus"`
	SetID         int32              `json:"set_id"`
	Weight        pgtype.Numeric     `json:"weight"`
	Reps          int32              `json:"reps"`
	SetType       string             `json:"set_type"`
	ExerciseID    int32              `json:"exercise_id"`
	ExerciseName  string             `json:"exercise_name"`
	ExerciseOrder int32              `json:"exercise_order"`
	SetOrder      int32              `json:"set_order"`
	Volume        pgtype.Numeric     `json:"volume"`
}

func (q *Queries) GetExerciseWithSets(ctx context.Context, arg GetExerciseWithSetsParams) ([]GetExerciseWithSetsRow, error) {
	rows, err := q.db.Query(ctx, getExerciseWithSets, arg.ExerciseID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExerciseWithSetsRow
	for rows.Next() {
		var i GetExerciseWithSetsRow
		if err := rows.Scan(
			&i.WorkoutID,
			&i.WorkoutDate,
			&i.WorkoutNotes,
			&i.WorkoutFocus,
			&i.SetID,
			&i.Weight,
			&i.Reps,
			&i.SetType,
			&i.ExerciseID,
			&i.ExerciseName,
			&i.ExerciseOrder,
			&i.SetOrder,
			&i.Volume,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrCreateExercise = `-- name: GetOrCreateExercise :one
INSERT INTO exercise (name, user_id)
VALUES ($1, $2)
ON CONFLICT (user_id, name) DO UPDATE SET name = EXCLUDED.name
RETURNING id
`

type GetOrCreateExerciseParams struct {
	Name   string `json:"name"`
	UserID string `json:"user_id"`
}

func (q *Queries) GetOrCreateExercise(ctx context.Context, arg GetOrCreateExerciseParams) (int32, error) {
	row := q.db.QueryRow(ctx, getOrCreateExercise, arg.Name, arg.UserID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getRecentSetsForExercise = `-- name: GetRecentSetsForExercise :many
SELECT 
    s.id AS set_id,
    w.id AS workout_id,
    w.date AS workout_date,
    w.workout_focus AS workout_focus,
    s.weight,
    s.reps,
    s.exercise_order,
    s.set_order,
    s.created_at
FROM "set" s
JOIN workout w ON w.id = s.workout_id
WHERE s.exercise_id = $1 AND s.user_id = $2
ORDER BY w.date DESC, s.exercise_order, s.set_order, s.created_at DESC
LIMIT 3
`

type GetRecentSetsForExerciseParams struct {
	ExerciseID int32  `json:"exercise_id"`
	UserID     string `json:"user_id"`
}

type GetRecentSetsForExerciseRow struct {
	SetID         int32              `json:"set_id"`
	WorkoutID     int32              `json:"workout_id"`
	WorkoutDate   pgtype.Timestamptz `json:"workout_date"`
	WorkoutFocus  pgtype.Text        `json:"workout_focus"`
	Weight        pgtype.Numeric     `json:"weight"`
	Reps          int32              `json:"reps"`
	ExerciseOrder int32              `json:"exercise_order"`
	SetOrder      int32              `json:"set_order"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetRecentSetsForExercise(ctx context.Context, arg GetRecentSetsForExerciseParams) ([]GetRecentSetsForExerciseRow, error) {
	rows, err := q.db.Query(ctx, getRecentSetsForExercise, arg.ExerciseID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecentSetsForExerciseRow
	for rows.Next() {
		var i GetRecentSetsForExerciseRow
		if err := rows.Scan(
			&i.SetID,
			&i.WorkoutID,
			&i.WorkoutDate,
			&i.WorkoutFocus,
			&i.Weight,
			&i.Reps,
			&i.ExerciseOrder,
			&i.SetOrder,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSet = `-- name: GetSet :one
SELECT id, exercise_id, workout_id, weight, reps, set_type, created_at, updated_at, exercise_order, set_order FROM "set"
WHERE id = $1 AND user_id = $2
`

type GetSetParams struct {
	ID     int32  `json:"id"`
	UserID string `json:"user_id"`
}

type GetSetRow struct {
	ID            int32              `json:"id"`
	ExerciseID    int32              `json:"exercise_id"`
	WorkoutID     int32              `json:"workout_id"`
	Weight        pgtype.Numeric     `json:"weight"`
	Reps          int32              `json:"reps"`
	SetType       string             `json:"set_type"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	ExerciseOrder int32              `json:"exercise_order"`
	SetOrder      int32              `json:"set_order"`
}

func (q *Queries) GetSet(ctx context.Context, arg GetSetParams) (GetSetRow, error) {
	row := q.db.QueryRow(ctx, getSet, arg.ID, arg.UserID)
	var i GetSetRow
	err := row.Scan(
		&i.ID,
		&i.ExerciseID,
		&i.WorkoutID,
		&i.Weight,
		&i.Reps,
		&i.SetType,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExerciseOrder,
		&i.SetOrder,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT id, user_id, created_at FROM users WHERE id = $1
`

// User queries
func (q *Queries) GetUser(ctx context.Context, id int32) (Users, error) {
	row := q.db.QueryRow(ctx, getUser, id)
	var i Users
	err := row.Scan(&i.ID, &i.UserID, &i.CreatedAt)
	return i, err
}

const getUserByUserID = `-- name: GetUserByUserID :one
SELECT id, user_id, created_at FROM users WHERE user_id = $1 LIMIT 1
`

func (q *Queries) GetUserByUserID(ctx context.Context, userID string) (Users, error) {
	row := q.db.QueryRow(ctx, getUserByUserID, userID)
	var i Users
	err := row.Scan(&i.ID, &i.UserID, &i.CreatedAt)
	return i, err
}

const getWorkout = `-- name: GetWorkout :one
SELECT id, date, notes, workout_focus, created_at, updated_at FROM workout WHERE id = $1 AND user_id = $2
`

type GetWorkoutParams struct {
	ID     int32  `json:"id"`
	UserID string `json:"user_id"`
}

type GetWorkoutRow struct {
	ID           int32              `json:"id"`
	Date         pgtype.Timestamptz `json:"date"`
	Notes        pgtype.Text        `json:"notes"`
	WorkoutFocus pgtype.Text        `json:"workout_focus"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

// Basic SELECT queries
func (q *Queries) GetWorkout(ctx context.Context, arg GetWorkoutParams) (GetWorkoutRow, error) {
	row := q.db.QueryRow(ctx, getWorkout, arg.ID, arg.UserID)
	var i GetWorkoutRow
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.Notes,
		&i.WorkoutFocus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWorkoutWithSets = `-- name: GetWorkoutWithSets :many
SELECT 
    w.id as workout_id,
    w.date as workout_date,
    w.notes as workout_notes,
    w.workout_focus as workout_focus,
    s.id as set_id,
    s.weight,
    s.reps,
    s.set_type,
    e.id as exercise_id,
    e.name as exercise_name,
    s.exercise_order,
    s.set_order,
    (COALESCE(s.weight, 0) * s.reps)::NUMERIC(10,1) as volume
FROM workout w
JOIN "set" s ON w.id = s.workout_id
JOIN exercise e ON s.exercise_id = e.id
WHERE w.id = $1 AND w.user_id = $2
ORDER BY s.exercise_order, s.set_order, s.id
`

type GetWorkoutWithSetsParams struct {
	ID     int32  `json:"id"`
	UserID string `json:"user_id"`
}

type GetWorkoutWithSetsRow struct {
	WorkoutID     int32              `json:"workout_id"`
	WorkoutDate   pgtype.Timestamptz `json:"workout_date"`
	WorkoutNotes  pgtype.Text        `json:"workout_notes"`
	WorkoutFocus  pgtype.Text        `json:"workout_focus"`
	SetID         int32              `json:"set_id"`
	Weight        pgtype.Numeric     `json:"weight"`
	Reps          int32              `json:"reps"`
	SetType       string             `json:"set_type"`
	ExerciseID    int32              `json:"exercise_id"`
	ExerciseName  string             `json:"exercise_name"`
	ExerciseOrder int32              `json:"exercise_order"`
	SetOrder      int32              `json:"set_order"`
	Volume        pgtype.Numeric     `json:"volume"`
}

// Complex queries for joining data
func (q *Queries) GetWorkoutWithSets(ctx context.Context, arg GetWorkoutWithSetsParams) ([]GetWorkoutWithSetsRow, error) {
	rows, err := q.db.Query(ctx, getWorkoutWithSets, arg.ID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWorkoutWithSetsRow
	for rows.Next() {
		var i GetWorkoutWithSetsRow
		if err := rows.Scan(
			&i.WorkoutID,
			&i.WorkoutDate,
			&i.WorkoutNotes,
			&i.WorkoutFocus,
			&i.SetID,
			&i.Weight,
			&i.Reps,
			&i.SetType,
			&i.ExerciseID,
			&i.ExerciseName,
			&i.ExerciseOrder,
			&i.SetOrder,
			&i.Volume,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExercises = `-- name: ListExercises :many
SELECT id, name FROM exercise WHERE user_id = $1 ORDER BY name
`

type ListExercisesRow struct {
	ID   int32  `json:"id"`
	Name string `json:"name"`
}

func (q *Queries) ListExercises(ctx context.Context, userID string) ([]ListExercisesRow, error) {
	rows, err := q.db.Query(ctx, listExercises, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListExercisesRow
	for rows.Next() {
		var i ListExercisesRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSets = `-- name: ListSets :many
SELECT id, exercise_id, workout_id, weight, reps, set_type, created_at, updated_at, exercise_order, set_order FROM "set"
WHERE user_id = $1
ORDER BY exercise_order, set_order, id
`

type ListSetsRow struct {
	ID            int32              `json:"id"`
	ExerciseID    int32              `json:"exercise_id"`
	WorkoutID     int32              `json:"workout_id"`
	Weight        pgtype.Numeric     `json:"weight"`
	Reps          int32              `json:"reps"`
	SetType       string             `json:"set_type"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	ExerciseOrder int32              `json:"exercise_order"`
	SetOrder      int32              `json:"set_order"`
}

func (q *Queries) ListSets(ctx context.Context, userID string) ([]ListSetsRow, error) {
	rows, err := q.db.Query(ctx, listSets, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSetsRow
	for rows.Next() {
		var i ListSetsRow
		if err := rows.Scan(
			&i.ID,
			&i.ExerciseID,
			&i.WorkoutID,
			&i.Weight,
			&i.Reps,
			&i.SetType,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ExerciseOrder,
			&i.SetOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkoutFocusValues = `-- name: ListWorkoutFocusValues :many
SELECT DISTINCT workout_focus
FROM workout
WHERE user_id = $1
  AND workout_focus IS NOT NULL
ORDER BY workout_focus
`

func (q *Queries) ListWorkoutFocusValues(ctx context.Context, userID string) ([]pgtype.Text, error) {
	rows, err := q.db.Query(ctx, listWorkoutFocusValues, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.Text
	for rows.Next() {
		var workout_focus pgtype.Text
		if err := rows.Scan(&workout_focus); err != nil {
			return nil, err
		}
		items = append(items, workout_focus)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkouts = `-- name: ListWorkouts :many
SELECT id, date, notes, workout_focus, created_at, updated_at FROM workout WHERE user_id = $1 ORDER BY date DESC
`

type ListWorkoutsRow struct {
	ID           int32              `json:"id"`
	Date         pgtype.Timestamptz `json:"date"`
	Notes        pgtype.Text        `json:"notes"`
	WorkoutFocus pgtype.Text        `json:"workout_focus"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) ListWorkouts(ctx context.Context, userID string) ([]ListWorkoutsRow, error) {
	rows, err := q.db.Query(ctx, listWorkouts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListWorkoutsRow
	for rows.Next() {
		var i ListWorkoutsRow
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.Notes,
			&i.WorkoutFocus,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateExerciseName = `-- name: UpdateExerciseName :exec
UPDATE exercise
SET name = $2, updated_at = NOW()
WHERE id = $1 AND user_id = $3
`

type UpdateExerciseNameParams struct {
	ID     int32  `json:"id"`
	Name   string `json:"name"`
	UserID string `json:"user_id"`
}

func (q *Queries) UpdateExerciseName(ctx context.Context, arg UpdateExerciseNameParams) error {
	_, err := q.db.Exec(ctx, updateExerciseName, arg.ID, arg.Name, arg.UserID)
	return err
}

const updateSet = `-- name: UpdateSet :one
UPDATE "set"
SET
    weight = COALESCE($2, weight),
    reps = COALESCE($3, reps),
    set_type = COALESCE($4, set_type),
    updated_at = NOW()
WHERE id = $1 AND user_id = $5
RETURNING id
`

type UpdateSetParams struct {
	ID      int32          `json:"id"`
	Weight  pgtype.Numeric `json:"weight"`
	Reps    int32          `json:"reps"`
	SetType string         `json:"set_type"`
	UserID  string         `json:"user_id"`
}

func (q *Queries) UpdateSet(ctx context.Context, arg UpdateSetParams) (int32, error) {
	row := q.db.QueryRow(ctx, updateSet,
		arg.ID,
		arg.Weight,
		arg.Reps,
		arg.SetType,
		arg.UserID,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const updateWorkout = `-- name: UpdateWorkout :one
UPDATE workout
SET
    date = COALESCE($2, date),
    notes = COALESCE($3, notes),
    workout_focus = COALESCE($4, workout_focus),
    updated_at = NOW()
WHERE id = $1 AND user_id = $5
RETURNING id
`

type UpdateWorkoutParams struct {
	ID           int32              `json:"id"`
	Date         pgtype.Timestamptz `json:"date"`
	Notes        pgtype.Text        `json:"notes"`
	WorkoutFocus pgtype.Text        `json:"workout_focus"`
	UserID       string             `json:"user_id"`
}

// UPDATE queries for PUT endpoint
func (q *Queries) UpdateWorkout(ctx context.Context, arg UpdateWorkoutParams) (int32, error) {
	row := q.db.QueryRow(ctx, updateWorkout,
		arg.ID,
		arg.Date,
		arg.Notes,
		arg.WorkoutFocus,
		arg.UserID,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}
