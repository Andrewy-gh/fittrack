// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSet = `-- name: CreateSet :one
INSERT INTO "set" (exercise_id, workout_id, weight, reps, set_type, user_id, exercise_order, set_order)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id
`

type CreateSetParams struct {
	ExerciseID    int32          `json:"exercise_id"`
	WorkoutID     int32          `json:"workout_id"`
	Weight        pgtype.Numeric `json:"weight"`
	Reps          int32          `json:"reps"`
	SetType       string         `json:"set_type"`
	UserID        string         `json:"user_id"`
	ExerciseOrder int32          `json:"exercise_order"`
	SetOrder      int32          `json:"set_order"`
}

func (q *Queries) CreateSet(ctx context.Context, arg CreateSetParams) (int32, error) {
	row := q.db.QueryRow(ctx, createSet,
		arg.ExerciseID,
		arg.WorkoutID,
		arg.Weight,
		arg.Reps,
		arg.SetType,
		arg.UserID,
		arg.ExerciseOrder,
		arg.SetOrder,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (user_id)
VALUES ($1)
RETURNING id
`

func (q *Queries) CreateUser(ctx context.Context, userID string) (int32, error) {
	row := q.db.QueryRow(ctx, createUser, userID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createWorkout = `-- name: CreateWorkout :one
INSERT INTO workout (date, notes, workout_focus, user_id)
VALUES ($1, $2, $3, $4)
RETURNING id
`

type CreateWorkoutParams struct {
	Date         pgtype.Timestamptz `json:"date"`
	Notes        pgtype.Text        `json:"notes"`
	WorkoutFocus pgtype.Text        `json:"workout_focus"`
	UserID       string             `json:"user_id"`
}

// INSERT queries for form submission
func (q *Queries) CreateWorkout(ctx context.Context, arg CreateWorkoutParams) (int32, error) {
	row := q.db.QueryRow(ctx, createWorkout,
		arg.Date,
		arg.Notes,
		arg.WorkoutFocus,
		arg.UserID,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deleteExercise = `-- name: DeleteExercise :exec
DELETE FROM exercise WHERE id = $1 AND user_id = $2
`

type DeleteExerciseParams struct {
	ID     int32  `json:"id"`
	UserID string `json:"user_id"`
}

func (q *Queries) DeleteExercise(ctx context.Context, arg DeleteExerciseParams) error {
	_, err := q.db.Exec(ctx, deleteExercise, arg.ID, arg.UserID)
	return err
}

const deleteSetsByWorkout = `-- name: DeleteSetsByWorkout :exec
DELETE FROM "set" 
WHERE workout_id = $1 AND user_id = $2
`

type DeleteSetsByWorkoutParams struct {
	WorkoutID int32  `json:"workout_id"`
	UserID    string `json:"user_id"`
}

func (q *Queries) DeleteSetsByWorkout(ctx context.Context, arg DeleteSetsByWorkoutParams) error {
	_, err := q.db.Exec(ctx, deleteSetsByWorkout, arg.WorkoutID, arg.UserID)
	return err
}

const deleteSetsByWorkoutAndExercise = `-- name: DeleteSetsByWorkoutAndExercise :exec
DELETE FROM "set" 
WHERE workout_id = $1 
  AND exercise_id = $2
  AND user_id = $3
`

type DeleteSetsByWorkoutAndExerciseParams struct {
	WorkoutID  int32  `json:"workout_id"`
	ExerciseID int32  `json:"exercise_id"`
	UserID     string `json:"user_id"`
}

func (q *Queries) DeleteSetsByWorkoutAndExercise(ctx context.Context, arg DeleteSetsByWorkoutAndExerciseParams) error {
	_, err := q.db.Exec(ctx, deleteSetsByWorkoutAndExercise, arg.WorkoutID, arg.ExerciseID, arg.UserID)
	return err
}

const deleteWorkout = `-- name: DeleteWorkout :exec
DELETE FROM workout 
WHERE id = $1 
  AND user_id = $2
`

type DeleteWorkoutParams struct {
	ID     int32  `json:"id"`
	UserID string `json:"user_id"`
}

func (q *Queries) DeleteWorkout(ctx context.Context, arg DeleteWorkoutParams) error {
	_, err := q.db.Exec(ctx, deleteWorkout, arg.ID, arg.UserID)
	return err
}

const getContributionData = `-- name: GetContributionData :many
SELECT
    DATE_TRUNC('day', w.date)::DATE as date,
    COUNT(s.id)::INTEGER as count,
    JSON_AGG(DISTINCT JSONB_BUILD_OBJECT(
        'id', w.id,
        'time', w.date,
        'focus', w.workout_focus
    )) as workouts
FROM workout w
LEFT JOIN "set" s ON s.workout_id = w.id AND s.set_type = 'working'
WHERE w.user_id = $1
  AND w.date >= CURRENT_DATE - INTERVAL '52 weeks'
GROUP BY DATE_TRUNC('day', w.date)
ORDER BY date
`

type GetContributionDataRow struct {
	Date     pgtype.Date `json:"date"`
	Count    int32       `json:"count"`
	Workouts []byte      `json:"workouts"`
}

// Security: This query is protected by both application-level filtering and RLS policies.
// The WHERE clause filters by user_id (parameter $1), ensuring only the authenticated user's
// workouts are retrieved. RLS policies on the workout table provide defense-in-depth.
// The GROUP BY on date and JSON_AGG of workout metadata ensures no cross-user data leakage.
func (q *Queries) GetContributionData(ctx context.Context, userID string) ([]GetContributionDataRow, error) {
	rows, err := q.db.Query(ctx, getContributionData, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetContributionDataRow
	for rows.Next() {
		var i GetContributionDataRow
		if err := rows.Scan(&i.Date, &i.Count, &i.Workouts); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExercise = `-- name: GetExercise :one
SELECT id, name FROM exercise WHERE id = $1 AND user_id = $2
`

type GetExerciseParams struct {
	ID     int32  `json:"id"`
	UserID string `json:"user_id"`
}

type GetExerciseRow struct {
	ID   int32  `json:"id"`
	Name string `json:"name"`
}

func (q *Queries) GetExercise(ctx context.Context, arg GetExerciseParams) (GetExerciseRow, error) {
	row := q.db.QueryRow(ctx, getExercise, arg.ID, arg.UserID)
	var i GetExerciseRow
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getExerciseBestE1rmWithWorkout = `-- name: GetExerciseBestE1rmWithWorkout :one
WITH working AS (
    SELECT
        s.workout_id,
        w.date AS workout_date,
        (COALESCE(s.weight, 0)::numeric * (1 + s.reps::numeric / 30))::numeric(8,2) AS e1rm
    FROM "set" s
    JOIN workout w ON w.id = s.workout_id
    WHERE s.user_id = $1
      AND s.exercise_id = $2
      AND s.set_type = 'working'
)
SELECT workout_id, e1rm
FROM working
ORDER BY e1rm DESC, workout_date DESC, workout_id DESC
LIMIT 1
`

type GetExerciseBestE1rmWithWorkoutParams struct {
	UserID     string `json:"user_id"`
	ExerciseID int32  `json:"exercise_id"`
}

type GetExerciseBestE1rmWithWorkoutRow struct {
	WorkoutID int32          `json:"workout_id"`
	E1rm      pgtype.Numeric `json:"e1rm"`
}

func (q *Queries) GetExerciseBestE1rmWithWorkout(ctx context.Context, arg GetExerciseBestE1rmWithWorkoutParams) (GetExerciseBestE1rmWithWorkoutRow, error) {
	row := q.db.QueryRow(ctx, getExerciseBestE1rmWithWorkout, arg.UserID, arg.ExerciseID)
	var i GetExerciseBestE1rmWithWorkoutRow
	err := row.Scan(&i.WorkoutID, &i.E1rm)
	return i, err
}

const getExerciseBestE1rmWithWorkoutExcludingWorkout = `-- name: GetExerciseBestE1rmWithWorkoutExcludingWorkout :one
WITH working AS (
    SELECT
        s.workout_id,
        w.date AS workout_date,
        (COALESCE(s.weight, 0)::numeric * (1 + s.reps::numeric / 30))::numeric(8,2) AS e1rm
    FROM "set" s
    JOIN workout w ON w.id = s.workout_id
    WHERE s.user_id = $1
      AND s.exercise_id = $2
      AND s.workout_id <> $3
      AND s.set_type = 'working'
)
SELECT workout_id, e1rm
FROM working
ORDER BY e1rm DESC, workout_date DESC, workout_id DESC
LIMIT 1
`

type GetExerciseBestE1rmWithWorkoutExcludingWorkoutParams struct {
	UserID     string `json:"user_id"`
	ExerciseID int32  `json:"exercise_id"`
	WorkoutID  int32  `json:"workout_id"`
}

type GetExerciseBestE1rmWithWorkoutExcludingWorkoutRow struct {
	WorkoutID int32          `json:"workout_id"`
	E1rm      pgtype.Numeric `json:"e1rm"`
}

func (q *Queries) GetExerciseBestE1rmWithWorkoutExcludingWorkout(ctx context.Context, arg GetExerciseBestE1rmWithWorkoutExcludingWorkoutParams) (GetExerciseBestE1rmWithWorkoutExcludingWorkoutRow, error) {
	row := q.db.QueryRow(ctx, getExerciseBestE1rmWithWorkoutExcludingWorkout, arg.UserID, arg.ExerciseID, arg.WorkoutID)
	var i GetExerciseBestE1rmWithWorkoutExcludingWorkoutRow
	err := row.Scan(&i.WorkoutID, &i.E1rm)
	return i, err
}

const getExerciseByName = `-- name: GetExerciseByName :one
SELECT id, name FROM exercise WHERE name = $1 AND user_id = $2
`

type GetExerciseByNameParams struct {
	Name   string `json:"name"`
	UserID string `json:"user_id"`
}

type GetExerciseByNameRow struct {
	ID   int32  `json:"id"`
	Name string `json:"name"`
}

func (q *Queries) GetExerciseByName(ctx context.Context, arg GetExerciseByNameParams) (GetExerciseByNameRow, error) {
	row := q.db.QueryRow(ctx, getExerciseByName, arg.Name, arg.UserID)
	var i GetExerciseByNameRow
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getExerciseHistorical1RM = `-- name: GetExerciseHistorical1RM :one
SELECT historical_1rm, historical_1rm_updated_at, historical_1rm_source_workout_id
FROM exercise
WHERE id = $1 AND user_id = $2
`

type GetExerciseHistorical1RMParams struct {
	ID     int32  `json:"id"`
	UserID string `json:"user_id"`
}

type GetExerciseHistorical1RMRow struct {
	Historical1rm                pgtype.Numeric     `json:"historical_1rm"`
	Historical1rmUpdatedAt       pgtype.Timestamptz `json:"historical_1rm_updated_at"`
	Historical1rmSourceWorkoutID pgtype.Int4        `json:"historical_1rm_source_workout_id"`
}

func (q *Queries) GetExerciseHistorical1RM(ctx context.Context, arg GetExerciseHistorical1RMParams) (GetExerciseHistorical1RMRow, error) {
	row := q.db.QueryRow(ctx, getExerciseHistorical1RM, arg.ID, arg.UserID)
	var i GetExerciseHistorical1RMRow
	err := row.Scan(&i.Historical1rm, &i.Historical1rmUpdatedAt, &i.Historical1rmSourceWorkoutID)
	return i, err
}

const getExerciseMetricsHistoryMonthlyYear = `-- name: GetExerciseMetricsHistoryMonthlyYear :many
WITH working_sets AS (
    SELECT
        w.id AS workout_id,
        w.date AS workout_date,
        w.date::date AS workout_day,
        COALESCE(s.weight, 0)::numeric AS weight,
        s.reps AS reps,
        (COALESCE(s.weight, 0)::numeric * s.reps::numeric) AS volume,
        (COALESCE(s.weight, 0)::numeric * (1 + s.reps::numeric / 30)) AS e1rm,
        e.historical_1rm AS historical_1rm,
        MAX((COALESCE(s.weight, 0)::numeric * (1 + s.reps::numeric / 30))) OVER (PARTITION BY w.id) AS session_best_e1rm
    FROM "set" s
    JOIN workout w ON w.id = s.workout_id
    JOIN exercise e ON e.id = s.exercise_id
    WHERE s.exercise_id = $1
      AND s.user_id = $2
      AND s.set_type = 'working'
),
workout_metrics AS (
    SELECT
        workout_id,
        MIN(workout_day) AS workout_day,
        COALESCE(MAX(session_best_e1rm), 0)::float8 AS session_best_e1rm,
        COALESCE(AVG(e1rm), 0)::float8 AS session_avg_e1rm,
        COALESCE(AVG(
            CASE
                WHEN (CASE WHEN historical_1rm > 0 THEN historical_1rm ELSE session_best_e1rm END) > 0
                THEN (weight / (CASE WHEN historical_1rm > 0 THEN historical_1rm ELSE session_best_e1rm END) * 100)
            END
        ), 0)::float8 AS session_avg_intensity,
        COALESCE(MAX(
            CASE
                WHEN (CASE WHEN historical_1rm > 0 THEN historical_1rm ELSE session_best_e1rm END) > 0
                THEN (weight / (CASE WHEN historical_1rm > 0 THEN historical_1rm ELSE session_best_e1rm END) * 100)
            END
        ), 0)::float8 AS session_best_intensity,
        COALESCE(SUM(volume), 0)::float8 AS total_volume_working
    FROM working_sets
    GROUP BY workout_id
),
end_day AS (
    SELECT MAX(workout_day) AS end_day
    FROM workout_metrics
),
filtered_workouts AS (
    SELECT workout_id, workout_day, session_best_e1rm, session_avg_e1rm, session_avg_intensity, session_best_intensity, total_volume_working, end_day
    FROM workout_metrics, end_day
    WHERE workout_day >= end_day - interval '1 year'
),
bucketed AS (
    SELECT
        date_trunc('month', workout_day)::date AS bucket_day,
        COALESCE(MAX(session_best_e1rm), 0)::float8 AS session_best_e1rm,
        COALESCE(AVG(session_avg_e1rm), 0)::float8 AS session_avg_e1rm,
        COALESCE(AVG(session_avg_intensity), 0)::float8 AS session_avg_intensity,
        COALESCE(MAX(session_best_intensity), 0)::float8 AS session_best_intensity,
        COALESCE(AVG(total_volume_working), 0)::float8 AS total_volume_working
    FROM filtered_workouts
    GROUP BY bucket_day
)
SELECT bucket_day, session_best_e1rm, session_avg_e1rm, session_avg_intensity, session_best_intensity, total_volume_working
FROM (
    SELECT bucket_day, session_best_e1rm, session_avg_e1rm, session_avg_intensity, session_best_intensity, total_volume_working
    FROM bucketed
    ORDER BY bucket_day DESC
    LIMIT 12
) t
ORDER BY bucket_day ASC
`

type GetExerciseMetricsHistoryMonthlyYearParams struct {
	ExerciseID int32  `json:"exercise_id"`
	UserID     string `json:"user_id"`
}

type GetExerciseMetricsHistoryMonthlyYearRow struct {
	BucketDay            pgtype.Date `json:"bucket_day"`
	SessionBestE1rm      float64     `json:"session_best_e1rm"`
	SessionAvgE1rm       float64     `json:"session_avg_e1rm"`
	SessionAvgIntensity  float64     `json:"session_avg_intensity"`
	SessionBestIntensity float64     `json:"session_best_intensity"`
	TotalVolumeWorking   float64     `json:"total_volume_working"`
}

func (q *Queries) GetExerciseMetricsHistoryMonthlyYear(ctx context.Context, arg GetExerciseMetricsHistoryMonthlyYearParams) ([]GetExerciseMetricsHistoryMonthlyYearRow, error) {
	rows, err := q.db.Query(ctx, getExerciseMetricsHistoryMonthlyYear, arg.ExerciseID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExerciseMetricsHistoryMonthlyYearRow
	for rows.Next() {
		var i GetExerciseMetricsHistoryMonthlyYearRow
		if err := rows.Scan(
			&i.BucketDay,
			&i.SessionBestE1rm,
			&i.SessionAvgE1rm,
			&i.SessionAvgIntensity,
			&i.SessionBestIntensity,
			&i.TotalVolumeWorking,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExerciseMetricsHistoryRawMonth = `-- name: GetExerciseMetricsHistoryRawMonth :many
WITH working_sets AS (
    SELECT
        w.id AS workout_id,
        w.date::date AS workout_day,
        COALESCE(s.weight, 0)::numeric AS weight,
        s.reps AS reps,
        (COALESCE(s.weight, 0)::numeric * s.reps::numeric) AS volume,
        (COALESCE(s.weight, 0)::numeric * (1 + s.reps::numeric / 30)) AS e1rm,
        e.historical_1rm AS historical_1rm,
        MAX((COALESCE(s.weight, 0)::numeric * (1 + s.reps::numeric / 30))) OVER (PARTITION BY w.id) AS session_best_e1rm
    FROM "set" s
    JOIN workout w ON w.id = s.workout_id
    JOIN exercise e ON e.id = s.exercise_id
    WHERE s.exercise_id = $1
      AND s.user_id = $2
      AND s.set_type = 'working'
),
end_day AS (
    SELECT MAX(workout_day) AS end_day
    FROM working_sets
),
filtered AS (
    SELECT workout_id, workout_day, weight, reps, volume, e1rm, historical_1rm, session_best_e1rm, end_day
    FROM working_sets, end_day
    WHERE workout_day >= end_day - interval '30 days'
),
workout_metrics AS (
    SELECT
        workout_id,
        MIN(workout_day)::date AS workout_day,
        COALESCE(MAX(session_best_e1rm), 0)::float8 AS session_best_e1rm,
        COALESCE(AVG(e1rm), 0)::float8 AS session_avg_e1rm,
        COALESCE(AVG(
            CASE
                WHEN (CASE WHEN historical_1rm > 0 THEN historical_1rm ELSE session_best_e1rm END) > 0
                THEN (weight / (CASE WHEN historical_1rm > 0 THEN historical_1rm ELSE session_best_e1rm END) * 100)
            END
        ), 0)::float8 AS session_avg_intensity,
        COALESCE(MAX(
            CASE
                WHEN (CASE WHEN historical_1rm > 0 THEN historical_1rm ELSE session_best_e1rm END) > 0
                THEN (weight / (CASE WHEN historical_1rm > 0 THEN historical_1rm ELSE session_best_e1rm END) * 100)
            END
        ), 0)::float8 AS session_best_intensity,
        COALESCE(SUM(volume), 0)::float8 AS total_volume_working
    FROM filtered
    GROUP BY workout_id
)
SELECT workout_id, workout_day, session_best_e1rm, session_avg_e1rm, session_avg_intensity, session_best_intensity, total_volume_working
FROM workout_metrics
ORDER BY workout_day ASC
`

type GetExerciseMetricsHistoryRawMonthParams struct {
	ExerciseID int32  `json:"exercise_id"`
	UserID     string `json:"user_id"`
}

type GetExerciseMetricsHistoryRawMonthRow struct {
	WorkoutID            int32       `json:"workout_id"`
	WorkoutDay           pgtype.Date `json:"workout_day"`
	SessionBestE1rm      float64     `json:"session_best_e1rm"`
	SessionAvgE1rm       float64     `json:"session_avg_e1rm"`
	SessionAvgIntensity  float64     `json:"session_avg_intensity"`
	SessionBestIntensity float64     `json:"session_best_intensity"`
	TotalVolumeWorking   float64     `json:"total_volume_working"`
}

func (q *Queries) GetExerciseMetricsHistoryRawMonth(ctx context.Context, arg GetExerciseMetricsHistoryRawMonthParams) ([]GetExerciseMetricsHistoryRawMonthRow, error) {
	rows, err := q.db.Query(ctx, getExerciseMetricsHistoryRawMonth, arg.ExerciseID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExerciseMetricsHistoryRawMonthRow
	for rows.Next() {
		var i GetExerciseMetricsHistoryRawMonthRow
		if err := rows.Scan(
			&i.WorkoutID,
			&i.WorkoutDay,
			&i.SessionBestE1rm,
			&i.SessionAvgE1rm,
			&i.SessionAvgIntensity,
			&i.SessionBestIntensity,
			&i.TotalVolumeWorking,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExerciseMetricsHistoryRawWeek = `-- name: GetExerciseMetricsHistoryRawWeek :many
WITH working_sets AS (
    SELECT
        w.id AS workout_id,
        w.date::date AS workout_day,
        COALESCE(s.weight, 0)::numeric AS weight,
        s.reps AS reps,
        (COALESCE(s.weight, 0)::numeric * s.reps::numeric) AS volume,
        (COALESCE(s.weight, 0)::numeric * (1 + s.reps::numeric / 30)) AS e1rm,
        e.historical_1rm AS historical_1rm,
        MAX((COALESCE(s.weight, 0)::numeric * (1 + s.reps::numeric / 30))) OVER (PARTITION BY w.id) AS session_best_e1rm
    FROM "set" s
    JOIN workout w ON w.id = s.workout_id
    JOIN exercise e ON e.id = s.exercise_id
    WHERE s.exercise_id = $1
      AND s.user_id = $2
      AND s.set_type = 'working'
),
end_day AS (
    SELECT MAX(workout_day) AS end_day
    FROM working_sets
),
filtered AS (
    SELECT workout_id, workout_day, weight, reps, volume, e1rm, historical_1rm, session_best_e1rm, end_day
    FROM working_sets, end_day
    WHERE workout_day >= end_day - interval '7 days'
),
workout_metrics AS (
    SELECT
        workout_id,
        MIN(workout_day)::date AS workout_day,
        COALESCE(MAX(session_best_e1rm), 0)::float8 AS session_best_e1rm,
        COALESCE(AVG(e1rm), 0)::float8 AS session_avg_e1rm,
        COALESCE(AVG(
            CASE
                WHEN (CASE WHEN historical_1rm > 0 THEN historical_1rm ELSE session_best_e1rm END) > 0
                THEN (weight / (CASE WHEN historical_1rm > 0 THEN historical_1rm ELSE session_best_e1rm END) * 100)
            END
        ), 0)::float8 AS session_avg_intensity,
        COALESCE(MAX(
            CASE
                WHEN (CASE WHEN historical_1rm > 0 THEN historical_1rm ELSE session_best_e1rm END) > 0
                THEN (weight / (CASE WHEN historical_1rm > 0 THEN historical_1rm ELSE session_best_e1rm END) * 100)
            END
        ), 0)::float8 AS session_best_intensity,
        COALESCE(SUM(volume), 0)::float8 AS total_volume_working
    FROM filtered
    GROUP BY workout_id
)
SELECT workout_id, workout_day, session_best_e1rm, session_avg_e1rm, session_avg_intensity, session_best_intensity, total_volume_working
FROM workout_metrics
ORDER BY workout_day ASC
`

type GetExerciseMetricsHistoryRawWeekParams struct {
	ExerciseID int32  `json:"exercise_id"`
	UserID     string `json:"user_id"`
}

type GetExerciseMetricsHistoryRawWeekRow struct {
	WorkoutID            int32       `json:"workout_id"`
	WorkoutDay           pgtype.Date `json:"workout_day"`
	SessionBestE1rm      float64     `json:"session_best_e1rm"`
	SessionAvgE1rm       float64     `json:"session_avg_e1rm"`
	SessionAvgIntensity  float64     `json:"session_avg_intensity"`
	SessionBestIntensity float64     `json:"session_best_intensity"`
	TotalVolumeWorking   float64     `json:"total_volume_working"`
}

func (q *Queries) GetExerciseMetricsHistoryRawWeek(ctx context.Context, arg GetExerciseMetricsHistoryRawWeekParams) ([]GetExerciseMetricsHistoryRawWeekRow, error) {
	rows, err := q.db.Query(ctx, getExerciseMetricsHistoryRawWeek, arg.ExerciseID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExerciseMetricsHistoryRawWeekRow
	for rows.Next() {
		var i GetExerciseMetricsHistoryRawWeekRow
		if err := rows.Scan(
			&i.WorkoutID,
			&i.WorkoutDay,
			&i.SessionBestE1rm,
			&i.SessionAvgE1rm,
			&i.SessionAvgIntensity,
			&i.SessionBestIntensity,
			&i.TotalVolumeWorking,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExerciseMetricsHistoryWeekly6M = `-- name: GetExerciseMetricsHistoryWeekly6M :many
WITH working_sets AS (
    SELECT
        w.id AS workout_id,
        w.date AS workout_date,
        w.date::date AS workout_day,
        COALESCE(s.weight, 0)::numeric AS weight,
        s.reps AS reps,
        (COALESCE(s.weight, 0)::numeric * s.reps::numeric) AS volume,
        (COALESCE(s.weight, 0)::numeric * (1 + s.reps::numeric / 30)) AS e1rm,
        e.historical_1rm AS historical_1rm,
        MAX((COALESCE(s.weight, 0)::numeric * (1 + s.reps::numeric / 30))) OVER (PARTITION BY w.id) AS session_best_e1rm
    FROM "set" s
    JOIN workout w ON w.id = s.workout_id
    JOIN exercise e ON e.id = s.exercise_id
    WHERE s.exercise_id = $1
      AND s.user_id = $2
      AND s.set_type = 'working'
),
workout_metrics AS (
    SELECT
        workout_id,
        MIN(workout_day) AS workout_day,
        COALESCE(MAX(session_best_e1rm), 0)::float8 AS session_best_e1rm,
        COALESCE(AVG(e1rm), 0)::float8 AS session_avg_e1rm,
        COALESCE(AVG(
            CASE
                WHEN (CASE WHEN historical_1rm > 0 THEN historical_1rm ELSE session_best_e1rm END) > 0
                THEN (weight / (CASE WHEN historical_1rm > 0 THEN historical_1rm ELSE session_best_e1rm END) * 100)
            END
        ), 0)::float8 AS session_avg_intensity,
        COALESCE(MAX(
            CASE
                WHEN (CASE WHEN historical_1rm > 0 THEN historical_1rm ELSE session_best_e1rm END) > 0
                THEN (weight / (CASE WHEN historical_1rm > 0 THEN historical_1rm ELSE session_best_e1rm END) * 100)
            END
        ), 0)::float8 AS session_best_intensity,
        COALESCE(SUM(volume), 0)::float8 AS total_volume_working
    FROM working_sets
    GROUP BY workout_id
),
end_day AS (
    SELECT MAX(workout_day) AS end_day
    FROM workout_metrics
),
filtered_workouts AS (
    SELECT workout_id, workout_day, session_best_e1rm, session_avg_e1rm, session_avg_intensity, session_best_intensity, total_volume_working, end_day
    FROM workout_metrics, end_day
    WHERE workout_day >= end_day - interval '6 months'
),
bucketed AS (
    SELECT
        date_trunc('week', workout_day)::date AS bucket_day,
        COALESCE(MAX(session_best_e1rm), 0)::float8 AS session_best_e1rm,
        COALESCE(AVG(session_avg_e1rm), 0)::float8 AS session_avg_e1rm,
        COALESCE(AVG(session_avg_intensity), 0)::float8 AS session_avg_intensity,
        COALESCE(MAX(session_best_intensity), 0)::float8 AS session_best_intensity,
        COALESCE(AVG(total_volume_working), 0)::float8 AS total_volume_working
    FROM filtered_workouts
    GROUP BY bucket_day
)
SELECT bucket_day, session_best_e1rm, session_avg_e1rm, session_avg_intensity, session_best_intensity, total_volume_working
FROM (
    SELECT bucket_day, session_best_e1rm, session_avg_e1rm, session_avg_intensity, session_best_intensity, total_volume_working
    FROM bucketed
    ORDER BY bucket_day DESC
    LIMIT 26
) t
ORDER BY bucket_day ASC
`

type GetExerciseMetricsHistoryWeekly6MParams struct {
	ExerciseID int32  `json:"exercise_id"`
	UserID     string `json:"user_id"`
}

type GetExerciseMetricsHistoryWeekly6MRow struct {
	BucketDay            pgtype.Date `json:"bucket_day"`
	SessionBestE1rm      float64     `json:"session_best_e1rm"`
	SessionAvgE1rm       float64     `json:"session_avg_e1rm"`
	SessionAvgIntensity  float64     `json:"session_avg_intensity"`
	SessionBestIntensity float64     `json:"session_best_intensity"`
	TotalVolumeWorking   float64     `json:"total_volume_working"`
}

func (q *Queries) GetExerciseMetricsHistoryWeekly6M(ctx context.Context, arg GetExerciseMetricsHistoryWeekly6MParams) ([]GetExerciseMetricsHistoryWeekly6MRow, error) {
	rows, err := q.db.Query(ctx, getExerciseMetricsHistoryWeekly6M, arg.ExerciseID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExerciseMetricsHistoryWeekly6MRow
	for rows.Next() {
		var i GetExerciseMetricsHistoryWeekly6MRow
		if err := rows.Scan(
			&i.BucketDay,
			&i.SessionBestE1rm,
			&i.SessionAvgE1rm,
			&i.SessionAvgIntensity,
			&i.SessionBestIntensity,
			&i.TotalVolumeWorking,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExerciseWithSets = `-- name: GetExerciseWithSets :many
SELECT 
    s.workout_id,
    w.date as workout_date,
    w.notes as workout_notes,
    w.workout_focus as workout_focus,
    s.id as set_id,
    s.weight,
    s.reps,
    s.set_type,
    e.id as exercise_id,
    e.name as exercise_name,
    e.historical_1rm as historical_1rm,
    e.historical_1rm_updated_at as historical_1rm_updated_at,
    e.historical_1rm_source_workout_id as historical_1rm_source_workout_id,
    s.exercise_order,
    s.set_order,
    (COALESCE(s.weight, 0) * s.reps)::NUMERIC(10,1) as volume
FROM "set" s
JOIN exercise e ON e.id = s.exercise_id
JOIN workout w ON w.id = s.workout_id
WHERE s.exercise_id = $1 AND s.user_id = $2
ORDER BY w.date DESC, s.exercise_order, s.set_order, s.created_at, s.id
`

type GetExerciseWithSetsParams struct {
	ExerciseID int32  `json:"exercise_id"`
	UserID     string `json:"user_id"`
}

type GetExerciseWithSetsRow struct {
	WorkoutID                    int32              `json:"workout_id"`
	WorkoutDate                  pgtype.Timestamptz `json:"workout_date"`
	WorkoutNotes                 pgtype.Text        `json:"workout_notes"`
	WorkoutFocus                 pgtype.Text        `json:"workout_focus"`
	SetID                        int32              `json:"set_id"`
	Weight                       pgtype.Numeric     `json:"weight"`
	Reps                         int32              `json:"reps"`
	SetType                      string             `json:"set_type"`
	ExerciseID                   int32              `json:"exercise_id"`
	ExerciseName                 string             `json:"exercise_name"`
	Historical1rm                pgtype.Numeric     `json:"historical_1rm"`
	Historical1rmUpdatedAt       pgtype.Timestamptz `json:"historical_1rm_updated_at"`
	Historical1rmSourceWorkoutID pgtype.Int4        `json:"historical_1rm_source_workout_id"`
	ExerciseOrder                int32              `json:"exercise_order"`
	SetOrder                     int32              `json:"set_order"`
	Volume                       pgtype.Numeric     `json:"volume"`
}

func (q *Queries) GetExerciseWithSets(ctx context.Context, arg GetExerciseWithSetsParams) ([]GetExerciseWithSetsRow, error) {
	rows, err := q.db.Query(ctx, getExerciseWithSets, arg.ExerciseID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExerciseWithSetsRow
	for rows.Next() {
		var i GetExerciseWithSetsRow
		if err := rows.Scan(
			&i.WorkoutID,
			&i.WorkoutDate,
			&i.WorkoutNotes,
			&i.WorkoutFocus,
			&i.SetID,
			&i.Weight,
			&i.Reps,
			&i.SetType,
			&i.ExerciseID,
			&i.ExerciseName,
			&i.Historical1rm,
			&i.Historical1rmUpdatedAt,
			&i.Historical1rmSourceWorkoutID,
			&i.ExerciseOrder,
			&i.SetOrder,
			&i.Volume,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrCreateExercise = `-- name: GetOrCreateExercise :one
INSERT INTO exercise (name, user_id)
VALUES ($1, $2)
ON CONFLICT (user_id, name) DO UPDATE SET name = EXCLUDED.name
RETURNING id
`

type GetOrCreateExerciseParams struct {
	Name   string `json:"name"`
	UserID string `json:"user_id"`
}

func (q *Queries) GetOrCreateExercise(ctx context.Context, arg GetOrCreateExerciseParams) (int32, error) {
	row := q.db.QueryRow(ctx, getOrCreateExercise, arg.Name, arg.UserID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getRecentSetsForExercise = `-- name: GetRecentSetsForExercise :many
SELECT
    s.id AS set_id,
    w.id AS workout_id,
    w.date AS workout_date,
    w.workout_focus AS workout_focus,
    s.weight,
    s.reps,
    s.exercise_order,
    s.set_order,
    s.created_at
FROM "set" s
JOIN workout w ON w.id = s.workout_id
WHERE s.exercise_id = $1 AND s.user_id = $2
ORDER BY w.date DESC, s.set_order DESC
LIMIT 3
`

type GetRecentSetsForExerciseParams struct {
	ExerciseID int32  `json:"exercise_id"`
	UserID     string `json:"user_id"`
}

type GetRecentSetsForExerciseRow struct {
	SetID         int32              `json:"set_id"`
	WorkoutID     int32              `json:"workout_id"`
	WorkoutDate   pgtype.Timestamptz `json:"workout_date"`
	WorkoutFocus  pgtype.Text        `json:"workout_focus"`
	Weight        pgtype.Numeric     `json:"weight"`
	Reps          int32              `json:"reps"`
	ExerciseOrder int32              `json:"exercise_order"`
	SetOrder      int32              `json:"set_order"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetRecentSetsForExercise(ctx context.Context, arg GetRecentSetsForExerciseParams) ([]GetRecentSetsForExerciseRow, error) {
	rows, err := q.db.Query(ctx, getRecentSetsForExercise, arg.ExerciseID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecentSetsForExerciseRow
	for rows.Next() {
		var i GetRecentSetsForExerciseRow
		if err := rows.Scan(
			&i.SetID,
			&i.WorkoutID,
			&i.WorkoutDate,
			&i.WorkoutFocus,
			&i.Weight,
			&i.Reps,
			&i.ExerciseOrder,
			&i.SetOrder,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSet = `-- name: GetSet :one
SELECT id, exercise_id, workout_id, weight, reps, set_type, created_at, updated_at, exercise_order, set_order FROM "set"
WHERE id = $1 AND user_id = $2
`

type GetSetParams struct {
	ID     int32  `json:"id"`
	UserID string `json:"user_id"`
}

type GetSetRow struct {
	ID            int32              `json:"id"`
	ExerciseID    int32              `json:"exercise_id"`
	WorkoutID     int32              `json:"workout_id"`
	Weight        pgtype.Numeric     `json:"weight"`
	Reps          int32              `json:"reps"`
	SetType       string             `json:"set_type"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	ExerciseOrder int32              `json:"exercise_order"`
	SetOrder      int32              `json:"set_order"`
}

func (q *Queries) GetSet(ctx context.Context, arg GetSetParams) (GetSetRow, error) {
	row := q.db.QueryRow(ctx, getSet, arg.ID, arg.UserID)
	var i GetSetRow
	err := row.Scan(
		&i.ID,
		&i.ExerciseID,
		&i.WorkoutID,
		&i.Weight,
		&i.Reps,
		&i.SetType,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExerciseOrder,
		&i.SetOrder,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT id, user_id, created_at FROM users WHERE id = $1
`

// User queries
func (q *Queries) GetUser(ctx context.Context, id int32) (Users, error) {
	row := q.db.QueryRow(ctx, getUser, id)
	var i Users
	err := row.Scan(&i.ID, &i.UserID, &i.CreatedAt)
	return i, err
}

const getUserByUserID = `-- name: GetUserByUserID :one
SELECT id, user_id, created_at FROM users WHERE user_id = $1 LIMIT 1
`

func (q *Queries) GetUserByUserID(ctx context.Context, userID string) (Users, error) {
	row := q.db.QueryRow(ctx, getUserByUserID, userID)
	var i Users
	err := row.Scan(&i.ID, &i.UserID, &i.CreatedAt)
	return i, err
}

const getWorkout = `-- name: GetWorkout :one
SELECT id, date, notes, workout_focus, created_at, updated_at FROM workout WHERE id = $1 AND user_id = $2
`

type GetWorkoutParams struct {
	ID     int32  `json:"id"`
	UserID string `json:"user_id"`
}

type GetWorkoutRow struct {
	ID           int32              `json:"id"`
	Date         pgtype.Timestamptz `json:"date"`
	Notes        pgtype.Text        `json:"notes"`
	WorkoutFocus pgtype.Text        `json:"workout_focus"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

// Basic SELECT queries
func (q *Queries) GetWorkout(ctx context.Context, arg GetWorkoutParams) (GetWorkoutRow, error) {
	row := q.db.QueryRow(ctx, getWorkout, arg.ID, arg.UserID)
	var i GetWorkoutRow
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.Notes,
		&i.WorkoutFocus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWorkoutBestE1rmByExercise = `-- name: GetWorkoutBestE1rmByExercise :many
SELECT
    s.exercise_id,
    MAX((COALESCE(s.weight, 0)::numeric * (1 + s.reps::numeric / 30)))::numeric(8,2) AS best_e1rm
FROM "set" s
WHERE s.workout_id = $1
  AND s.user_id = $2
  AND s.set_type = 'working'
GROUP BY s.exercise_id
`

type GetWorkoutBestE1rmByExerciseParams struct {
	WorkoutID int32  `json:"workout_id"`
	UserID    string `json:"user_id"`
}

type GetWorkoutBestE1rmByExerciseRow struct {
	ExerciseID int32          `json:"exercise_id"`
	BestE1rm   pgtype.Numeric `json:"best_e1rm"`
}

func (q *Queries) GetWorkoutBestE1rmByExercise(ctx context.Context, arg GetWorkoutBestE1rmByExerciseParams) ([]GetWorkoutBestE1rmByExerciseRow, error) {
	rows, err := q.db.Query(ctx, getWorkoutBestE1rmByExercise, arg.WorkoutID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWorkoutBestE1rmByExerciseRow
	for rows.Next() {
		var i GetWorkoutBestE1rmByExerciseRow
		if err := rows.Scan(&i.ExerciseID, &i.BestE1rm); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkoutWithSets = `-- name: GetWorkoutWithSets :many
SELECT 
    w.id as workout_id,
    w.date as workout_date,
    w.notes as workout_notes,
    w.workout_focus as workout_focus,
    s.id as set_id,
    s.weight,
    s.reps,
    s.set_type,
    e.id as exercise_id,
    e.name as exercise_name,
    s.exercise_order,
    s.set_order,
    (COALESCE(s.weight, 0) * s.reps)::NUMERIC(10,1) as volume
FROM workout w
JOIN "set" s ON w.id = s.workout_id
JOIN exercise e ON s.exercise_id = e.id
WHERE w.id = $1 AND w.user_id = $2
ORDER BY s.exercise_order, s.set_order, s.id
`

type GetWorkoutWithSetsParams struct {
	ID     int32  `json:"id"`
	UserID string `json:"user_id"`
}

type GetWorkoutWithSetsRow struct {
	WorkoutID     int32              `json:"workout_id"`
	WorkoutDate   pgtype.Timestamptz `json:"workout_date"`
	WorkoutNotes  pgtype.Text        `json:"workout_notes"`
	WorkoutFocus  pgtype.Text        `json:"workout_focus"`
	SetID         int32              `json:"set_id"`
	Weight        pgtype.Numeric     `json:"weight"`
	Reps          int32              `json:"reps"`
	SetType       string             `json:"set_type"`
	ExerciseID    int32              `json:"exercise_id"`
	ExerciseName  string             `json:"exercise_name"`
	ExerciseOrder int32              `json:"exercise_order"`
	SetOrder      int32              `json:"set_order"`
	Volume        pgtype.Numeric     `json:"volume"`
}

// Complex queries for joining data
func (q *Queries) GetWorkoutWithSets(ctx context.Context, arg GetWorkoutWithSetsParams) ([]GetWorkoutWithSetsRow, error) {
	rows, err := q.db.Query(ctx, getWorkoutWithSets, arg.ID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWorkoutWithSetsRow
	for rows.Next() {
		var i GetWorkoutWithSetsRow
		if err := rows.Scan(
			&i.WorkoutID,
			&i.WorkoutDate,
			&i.WorkoutNotes,
			&i.WorkoutFocus,
			&i.SetID,
			&i.Weight,
			&i.Reps,
			&i.SetType,
			&i.ExerciseID,
			&i.ExerciseName,
			&i.ExerciseOrder,
			&i.SetOrder,
			&i.Volume,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExercises = `-- name: ListExercises :many
SELECT id, name FROM exercise WHERE user_id = $1 ORDER BY name
`

type ListExercisesRow struct {
	ID   int32  `json:"id"`
	Name string `json:"name"`
}

func (q *Queries) ListExercises(ctx context.Context, userID string) ([]ListExercisesRow, error) {
	rows, err := q.db.Query(ctx, listExercises, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListExercisesRow
	for rows.Next() {
		var i ListExercisesRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExercisesWithHistorical1RMSourceWorkout = `-- name: ListExercisesWithHistorical1RMSourceWorkout :many
SELECT id
FROM exercise
WHERE user_id = $1 AND historical_1rm_source_workout_id = $2
`

type ListExercisesWithHistorical1RMSourceWorkoutParams struct {
	UserID                       string      `json:"user_id"`
	Historical1rmSourceWorkoutID pgtype.Int4 `json:"historical_1rm_source_workout_id"`
}

func (q *Queries) ListExercisesWithHistorical1RMSourceWorkout(ctx context.Context, arg ListExercisesWithHistorical1RMSourceWorkoutParams) ([]int32, error) {
	rows, err := q.db.Query(ctx, listExercisesWithHistorical1RMSourceWorkout, arg.UserID, arg.Historical1rmSourceWorkoutID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSets = `-- name: ListSets :many
SELECT id, exercise_id, workout_id, weight, reps, set_type, created_at, updated_at, exercise_order, set_order FROM "set"
WHERE user_id = $1
ORDER BY exercise_order, set_order, id
`

type ListSetsRow struct {
	ID            int32              `json:"id"`
	ExerciseID    int32              `json:"exercise_id"`
	WorkoutID     int32              `json:"workout_id"`
	Weight        pgtype.Numeric     `json:"weight"`
	Reps          int32              `json:"reps"`
	SetType       string             `json:"set_type"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	ExerciseOrder int32              `json:"exercise_order"`
	SetOrder      int32              `json:"set_order"`
}

func (q *Queries) ListSets(ctx context.Context, userID string) ([]ListSetsRow, error) {
	rows, err := q.db.Query(ctx, listSets, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSetsRow
	for rows.Next() {
		var i ListSetsRow
		if err := rows.Scan(
			&i.ID,
			&i.ExerciseID,
			&i.WorkoutID,
			&i.Weight,
			&i.Reps,
			&i.SetType,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ExerciseOrder,
			&i.SetOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkoutFocusValues = `-- name: ListWorkoutFocusValues :many
SELECT DISTINCT workout_focus
FROM workout
WHERE user_id = $1
  AND workout_focus IS NOT NULL
ORDER BY workout_focus
`

func (q *Queries) ListWorkoutFocusValues(ctx context.Context, userID string) ([]pgtype.Text, error) {
	rows, err := q.db.Query(ctx, listWorkoutFocusValues, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.Text
	for rows.Next() {
		var workout_focus pgtype.Text
		if err := rows.Scan(&workout_focus); err != nil {
			return nil, err
		}
		items = append(items, workout_focus)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkouts = `-- name: ListWorkouts :many
SELECT id, date, notes, workout_focus, created_at, updated_at FROM workout WHERE user_id = $1 ORDER BY date DESC
`

type ListWorkoutsRow struct {
	ID           int32              `json:"id"`
	Date         pgtype.Timestamptz `json:"date"`
	Notes        pgtype.Text        `json:"notes"`
	WorkoutFocus pgtype.Text        `json:"workout_focus"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) ListWorkouts(ctx context.Context, userID string) ([]ListWorkoutsRow, error) {
	rows, err := q.db.Query(ctx, listWorkouts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListWorkoutsRow
	for rows.Next() {
		var i ListWorkoutsRow
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.Notes,
			&i.WorkoutFocus,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setExerciseHistorical1RM = `-- name: SetExerciseHistorical1RM :exec
UPDATE exercise
SET
    historical_1rm = $2,
    historical_1rm_updated_at = NOW(),
    historical_1rm_source_workout_id = $3,
    updated_at = NOW()
WHERE id = $1 AND user_id = $4
`

type SetExerciseHistorical1RMParams struct {
	ID                           int32          `json:"id"`
	Historical1rm                pgtype.Numeric `json:"historical_1rm"`
	Historical1rmSourceWorkoutID pgtype.Int4    `json:"historical_1rm_source_workout_id"`
	UserID                       string         `json:"user_id"`
}

func (q *Queries) SetExerciseHistorical1RM(ctx context.Context, arg SetExerciseHistorical1RMParams) error {
	_, err := q.db.Exec(ctx, setExerciseHistorical1RM,
		arg.ID,
		arg.Historical1rm,
		arg.Historical1rmSourceWorkoutID,
		arg.UserID,
	)
	return err
}

const updateExerciseHistorical1RMFromWorkoutIfBetter = `-- name: UpdateExerciseHistorical1RMFromWorkoutIfBetter :exec
UPDATE exercise
SET
    historical_1rm = $2,
    historical_1rm_updated_at = NOW(),
    historical_1rm_source_workout_id = $3,
    updated_at = NOW()
WHERE id = $1
  AND user_id = $4
  AND (historical_1rm IS NULL OR historical_1rm < $2)
`

type UpdateExerciseHistorical1RMFromWorkoutIfBetterParams struct {
	ID                           int32          `json:"id"`
	Historical1rm                pgtype.Numeric `json:"historical_1rm"`
	Historical1rmSourceWorkoutID pgtype.Int4    `json:"historical_1rm_source_workout_id"`
	UserID                       string         `json:"user_id"`
}

func (q *Queries) UpdateExerciseHistorical1RMFromWorkoutIfBetter(ctx context.Context, arg UpdateExerciseHistorical1RMFromWorkoutIfBetterParams) error {
	_, err := q.db.Exec(ctx, updateExerciseHistorical1RMFromWorkoutIfBetter,
		arg.ID,
		arg.Historical1rm,
		arg.Historical1rmSourceWorkoutID,
		arg.UserID,
	)
	return err
}

const updateExerciseHistorical1RMManual = `-- name: UpdateExerciseHistorical1RMManual :exec
UPDATE exercise
SET
    historical_1rm = $2,
    historical_1rm_updated_at = NOW(),
    historical_1rm_source_workout_id = NULL,
    updated_at = NOW()
WHERE id = $1 AND user_id = $3
`

type UpdateExerciseHistorical1RMManualParams struct {
	ID            int32          `json:"id"`
	Historical1rm pgtype.Numeric `json:"historical_1rm"`
	UserID        string         `json:"user_id"`
}

func (q *Queries) UpdateExerciseHistorical1RMManual(ctx context.Context, arg UpdateExerciseHistorical1RMManualParams) error {
	_, err := q.db.Exec(ctx, updateExerciseHistorical1RMManual, arg.ID, arg.Historical1rm, arg.UserID)
	return err
}

const updateExerciseName = `-- name: UpdateExerciseName :exec
UPDATE exercise
SET name = $2, updated_at = NOW()
WHERE id = $1 AND user_id = $3
`

type UpdateExerciseNameParams struct {
	ID     int32  `json:"id"`
	Name   string `json:"name"`
	UserID string `json:"user_id"`
}

func (q *Queries) UpdateExerciseName(ctx context.Context, arg UpdateExerciseNameParams) error {
	_, err := q.db.Exec(ctx, updateExerciseName, arg.ID, arg.Name, arg.UserID)
	return err
}

const updateSet = `-- name: UpdateSet :one
UPDATE "set"
SET
    weight = COALESCE($2, weight),
    reps = COALESCE($3, reps),
    set_type = COALESCE($4, set_type),
    updated_at = NOW()
WHERE id = $1 AND user_id = $5
RETURNING id
`

type UpdateSetParams struct {
	ID      int32          `json:"id"`
	Weight  pgtype.Numeric `json:"weight"`
	Reps    int32          `json:"reps"`
	SetType string         `json:"set_type"`
	UserID  string         `json:"user_id"`
}

func (q *Queries) UpdateSet(ctx context.Context, arg UpdateSetParams) (int32, error) {
	row := q.db.QueryRow(ctx, updateSet,
		arg.ID,
		arg.Weight,
		arg.Reps,
		arg.SetType,
		arg.UserID,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const updateWorkout = `-- name: UpdateWorkout :one
UPDATE workout
SET
    date = COALESCE($2, date),
    notes = COALESCE($3, notes),
    workout_focus = COALESCE($4, workout_focus),
    updated_at = NOW()
WHERE id = $1 AND user_id = $5
RETURNING id
`

type UpdateWorkoutParams struct {
	ID           int32              `json:"id"`
	Date         pgtype.Timestamptz `json:"date"`
	Notes        pgtype.Text        `json:"notes"`
	WorkoutFocus pgtype.Text        `json:"workout_focus"`
	UserID       string             `json:"user_id"`
}

// UPDATE queries for PUT endpoint
func (q *Queries) UpdateWorkout(ctx context.Context, arg UpdateWorkoutParams) (int32, error) {
	row := q.db.QueryRow(ctx, updateWorkout,
		arg.ID,
		arg.Date,
		arg.Notes,
		arg.WorkoutFocus,
		arg.UserID,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}
