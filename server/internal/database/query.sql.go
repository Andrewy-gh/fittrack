// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSet = `-- name: CreateSet :one
INSERT INTO "set" (exercise_id, workout_id, weight, reps, set_type)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, exercise_id, workout_id, weight, reps, set_type, created_at, updated_at
`

type CreateSetParams struct {
	ExerciseID int32       `json:"exercise_id"`
	WorkoutID  int32       `json:"workout_id"`
	Weight     pgtype.Int4 `json:"weight"`
	Reps       int32       `json:"reps"`
	SetType    string      `json:"set_type"`
}

func (q *Queries) CreateSet(ctx context.Context, arg CreateSetParams) (Set, error) {
	row := q.db.QueryRow(ctx, createSet,
		arg.ExerciseID,
		arg.WorkoutID,
		arg.Weight,
		arg.Reps,
		arg.SetType,
	)
	var i Set
	err := row.Scan(
		&i.ID,
		&i.ExerciseID,
		&i.WorkoutID,
		&i.Weight,
		&i.Reps,
		&i.SetType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

type CreateSetsParams struct {
	ExerciseID int32       `json:"exercise_id"`
	WorkoutID  int32       `json:"workout_id"`
	Weight     pgtype.Int4 `json:"weight"`
	Reps       int32       `json:"reps"`
	SetType    string      `json:"set_type"`
}

const createWorkout = `-- name: CreateWorkout :one
INSERT INTO workout (date, notes)
VALUES ($1, $2)
RETURNING id, date, notes, created_at, updated_at
`

type CreateWorkoutParams struct {
	Date  pgtype.Timestamptz `json:"date"`
	Notes pgtype.Text        `json:"notes"`
}

// INSERT queries for form submission
func (q *Queries) CreateWorkout(ctx context.Context, arg CreateWorkoutParams) (Workout, error) {
	row := q.db.QueryRow(ctx, createWorkout, arg.Date, arg.Notes)
	var i Workout
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getExercise = `-- name: GetExercise :one
SELECT id, name, created_at, updated_at FROM exercise WHERE id = $1
`

func (q *Queries) GetExercise(ctx context.Context, id int32) (Exercise, error) {
	row := q.db.QueryRow(ctx, getExercise, id)
	var i Exercise
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getExerciseByName = `-- name: GetExerciseByName :one
SELECT id, name, created_at, updated_at FROM exercise WHERE name = $1
`

func (q *Queries) GetExerciseByName(ctx context.Context, name string) (Exercise, error) {
	row := q.db.QueryRow(ctx, getExerciseByName, name)
	var i Exercise
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getExerciseWithSets = `-- name: GetExerciseWithSets :many
SELECT 
    s.workout_id,
    w.date as workout_date,
    w.notes as workout_notes,
    s.id as set_id,
    s.weight,
    s.reps,
    s.set_type,
    s.exercise_id,
    e.name as exercise_name
FROM "set" s
JOIN exercise e ON e.id = s.exercise_id
JOIN workout w ON w.id = s.workout_id
WHERE s.exercise_id = $1  -- Changed from workout_id to exercise_id
ORDER BY w.date DESC, s.created_at
`

type GetExerciseWithSetsRow struct {
	WorkoutID    int32              `json:"workout_id"`
	WorkoutDate  pgtype.Timestamptz `json:"workout_date"`
	WorkoutNotes pgtype.Text        `json:"workout_notes"`
	SetID        int32              `json:"set_id"`
	Weight       pgtype.Int4        `json:"weight"`
	Reps         int32              `json:"reps"`
	SetType      string             `json:"set_type"`
	ExerciseID   int32              `json:"exercise_id"`
	ExerciseName string             `json:"exercise_name"`
}

func (q *Queries) GetExerciseWithSets(ctx context.Context, exerciseID int32) ([]GetExerciseWithSetsRow, error) {
	rows, err := q.db.Query(ctx, getExerciseWithSets, exerciseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExerciseWithSetsRow
	for rows.Next() {
		var i GetExerciseWithSetsRow
		if err := rows.Scan(
			&i.WorkoutID,
			&i.WorkoutDate,
			&i.WorkoutNotes,
			&i.SetID,
			&i.Weight,
			&i.Reps,
			&i.SetType,
			&i.ExerciseID,
			&i.ExerciseName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrCreateExercise = `-- name: GetOrCreateExercise :one
INSERT INTO exercise (name) 
VALUES ($1)
ON CONFLICT (name) DO UPDATE SET name = EXCLUDED.name
RETURNING id, name, created_at, updated_at
`

func (q *Queries) GetOrCreateExercise(ctx context.Context, name string) (Exercise, error) {
	row := q.db.QueryRow(ctx, getOrCreateExercise, name)
	var i Exercise
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSet = `-- name: GetSet :one
SELECT id, exercise_id, workout_id, weight, reps, set_type, created_at, updated_at FROM "set" WHERE id = $1
`

func (q *Queries) GetSet(ctx context.Context, id int32) (Set, error) {
	row := q.db.QueryRow(ctx, getSet, id)
	var i Set
	err := row.Scan(
		&i.ID,
		&i.ExerciseID,
		&i.WorkoutID,
		&i.Weight,
		&i.Reps,
		&i.SetType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWorkout = `-- name: GetWorkout :one
SELECT id, date, notes, created_at, updated_at FROM workout WHERE id = $1
`

// Basic SELECT queries
func (q *Queries) GetWorkout(ctx context.Context, id int32) (Workout, error) {
	row := q.db.QueryRow(ctx, getWorkout, id)
	var i Workout
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWorkoutWithSets = `-- name: GetWorkoutWithSets :many
SELECT 
    w.id as workout_id,
    w.date as workout_date,
    w.notes as workout_notes,
    s.id as set_id,
    s.weight,
    s.reps,
    s.set_type,
    e.id as exercise_id,
    e.name as exercise_name
FROM workout w
JOIN "set" s ON w.id = s.workout_id
JOIN exercise e ON s.exercise_id = e.id
WHERE w.id = $1
ORDER BY e.name, s.id
`

type GetWorkoutWithSetsRow struct {
	WorkoutID    int32              `json:"workout_id"`
	WorkoutDate  pgtype.Timestamptz `json:"workout_date"`
	WorkoutNotes pgtype.Text        `json:"workout_notes"`
	SetID        int32              `json:"set_id"`
	Weight       pgtype.Int4        `json:"weight"`
	Reps         int32              `json:"reps"`
	SetType      string             `json:"set_type"`
	ExerciseID   int32              `json:"exercise_id"`
	ExerciseName string             `json:"exercise_name"`
}

// Complex queries for joining data
func (q *Queries) GetWorkoutWithSets(ctx context.Context, id int32) ([]GetWorkoutWithSetsRow, error) {
	rows, err := q.db.Query(ctx, getWorkoutWithSets, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWorkoutWithSetsRow
	for rows.Next() {
		var i GetWorkoutWithSetsRow
		if err := rows.Scan(
			&i.WorkoutID,
			&i.WorkoutDate,
			&i.WorkoutNotes,
			&i.SetID,
			&i.Weight,
			&i.Reps,
			&i.SetType,
			&i.ExerciseID,
			&i.ExerciseName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExercises = `-- name: ListExercises :many
SELECT id, name, created_at, updated_at FROM exercise ORDER BY name
`

func (q *Queries) ListExercises(ctx context.Context) ([]Exercise, error) {
	rows, err := q.db.Query(ctx, listExercises)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Exercise
	for rows.Next() {
		var i Exercise
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSets = `-- name: ListSets :many
SELECT id, exercise_id, workout_id, weight, reps, set_type, created_at, updated_at FROM "set" ORDER BY id
`

func (q *Queries) ListSets(ctx context.Context) ([]Set, error) {
	rows, err := q.db.Query(ctx, listSets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Set
	for rows.Next() {
		var i Set
		if err := rows.Scan(
			&i.ID,
			&i.ExerciseID,
			&i.WorkoutID,
			&i.Weight,
			&i.Reps,
			&i.SetType,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkouts = `-- name: ListWorkouts :many
SELECT id, date, notes, created_at, updated_at FROM workout ORDER BY date DESC
`

func (q *Queries) ListWorkouts(ctx context.Context) ([]Workout, error) {
	rows, err := q.db.Query(ctx, listWorkouts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Workout
	for rows.Next() {
		var i Workout
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
