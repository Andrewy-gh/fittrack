// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSet = `-- name: CreateSet :one
INSERT INTO "set" (exercise_id, workout_id, weight, reps, set_type, user_id, exercise_order, set_order)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, exercise_id, workout_id, weight, reps, set_type, created_at, updated_at, user_id, exercise_order, set_order
`

type CreateSetParams struct {
	ExerciseID    int32       `json:"exercise_id"`
	WorkoutID     int32       `json:"workout_id"`
	Weight        pgtype.Int4 `json:"weight"`
	Reps          int32       `json:"reps"`
	SetType       string      `json:"set_type"`
	UserID        string      `json:"user_id"`
	ExerciseOrder int32       `json:"exercise_order"`
	SetOrder      int32       `json:"set_order"`
}

func (q *Queries) CreateSet(ctx context.Context, arg CreateSetParams) (Set, error) {
	row := q.db.QueryRow(ctx, createSet,
		arg.ExerciseID,
		arg.WorkoutID,
		arg.Weight,
		arg.Reps,
		arg.SetType,
		arg.UserID,
		arg.ExerciseOrder,
		arg.SetOrder,
	)
	var i Set
	err := row.Scan(
		&i.ID,
		&i.ExerciseID,
		&i.WorkoutID,
		&i.Weight,
		&i.Reps,
		&i.SetType,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.ExerciseOrder,
		&i.SetOrder,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (user_id)
VALUES ($1)
RETURNING id, user_id, created_at
`

func (q *Queries) CreateUser(ctx context.Context, userID string) (Users, error) {
	row := q.db.QueryRow(ctx, createUser, userID)
	var i Users
	err := row.Scan(&i.ID, &i.UserID, &i.CreatedAt)
	return i, err
}

const createWorkout = `-- name: CreateWorkout :one
INSERT INTO workout (date, notes, user_id)
VALUES ($1, $2, $3)
RETURNING id, date, notes, created_at, updated_at, user_id
`

type CreateWorkoutParams struct {
	Date   pgtype.Timestamptz `json:"date"`
	Notes  pgtype.Text        `json:"notes"`
	UserID string             `json:"user_id"`
}

// INSERT queries for form submission
func (q *Queries) CreateWorkout(ctx context.Context, arg CreateWorkoutParams) (Workout, error) {
	row := q.db.QueryRow(ctx, createWorkout, arg.Date, arg.Notes, arg.UserID)
	var i Workout
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
	)
	return i, err
}

const deleteSetsByWorkout = `-- name: DeleteSetsByWorkout :exec
DELETE FROM "set" 
WHERE workout_id = $1 AND user_id = $2
`

type DeleteSetsByWorkoutParams struct {
	WorkoutID int32  `json:"workout_id"`
	UserID    string `json:"user_id"`
}

func (q *Queries) DeleteSetsByWorkout(ctx context.Context, arg DeleteSetsByWorkoutParams) error {
	_, err := q.db.Exec(ctx, deleteSetsByWorkout, arg.WorkoutID, arg.UserID)
	return err
}

const deleteSetsByWorkoutAndExercise = `-- name: DeleteSetsByWorkoutAndExercise :exec
DELETE FROM "set" 
WHERE workout_id = $1 
  AND exercise_id = $2
  AND user_id = $3
`

type DeleteSetsByWorkoutAndExerciseParams struct {
	WorkoutID  int32  `json:"workout_id"`
	ExerciseID int32  `json:"exercise_id"`
	UserID     string `json:"user_id"`
}

func (q *Queries) DeleteSetsByWorkoutAndExercise(ctx context.Context, arg DeleteSetsByWorkoutAndExerciseParams) error {
	_, err := q.db.Exec(ctx, deleteSetsByWorkoutAndExercise, arg.WorkoutID, arg.ExerciseID, arg.UserID)
	return err
}

const deleteWorkout = `-- name: DeleteWorkout :exec
DELETE FROM workout 
WHERE id = $1 
  AND user_id = $2
`

type DeleteWorkoutParams struct {
	ID     int32  `json:"id"`
	UserID string `json:"user_id"`
}

func (q *Queries) DeleteWorkout(ctx context.Context, arg DeleteWorkoutParams) error {
	_, err := q.db.Exec(ctx, deleteWorkout, arg.ID, arg.UserID)
	return err
}

const getExercise = `-- name: GetExercise :one
SELECT id, name, created_at, updated_at, user_id FROM exercise WHERE id = $1 AND user_id = $2
`

type GetExerciseParams struct {
	ID     int32  `json:"id"`
	UserID string `json:"user_id"`
}

func (q *Queries) GetExercise(ctx context.Context, arg GetExerciseParams) (Exercise, error) {
	row := q.db.QueryRow(ctx, getExercise, arg.ID, arg.UserID)
	var i Exercise
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
	)
	return i, err
}

const getExerciseByName = `-- name: GetExerciseByName :one
SELECT id, name, created_at, updated_at, user_id FROM exercise WHERE name = $1 AND user_id = $2
`

type GetExerciseByNameParams struct {
	Name   string `json:"name"`
	UserID string `json:"user_id"`
}

func (q *Queries) GetExerciseByName(ctx context.Context, arg GetExerciseByNameParams) (Exercise, error) {
	row := q.db.QueryRow(ctx, getExerciseByName, arg.Name, arg.UserID)
	var i Exercise
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
	)
	return i, err
}

const getExerciseWithSets = `-- name: GetExerciseWithSets :many
SELECT 
    s.workout_id,
    w.date as workout_date,
    w.notes as workout_notes,
    s.id as set_id,
    s.weight,
    s.reps,
    s.set_type,
    e.id as exercise_id,
    e.name as exercise_name,
    s.exercise_order,
    s.set_order,
    (COALESCE(s.weight, 0) * s.reps) as volume
FROM "set" s
JOIN exercise e ON e.id = s.exercise_id
JOIN workout w ON w.id = s.workout_id
WHERE s.exercise_id = $1 AND s.user_id = $2
ORDER BY w.date DESC, s.exercise_order, s.set_order, s.created_at, s.id
`

type GetExerciseWithSetsParams struct {
	ExerciseID int32  `json:"exercise_id"`
	UserID     string `json:"user_id"`
}

type GetExerciseWithSetsRow struct {
	WorkoutID     int32              `json:"workout_id"`
	WorkoutDate   pgtype.Timestamptz `json:"workout_date"`
	WorkoutNotes  pgtype.Text        `json:"workout_notes"`
	SetID         int32              `json:"set_id"`
	Weight        pgtype.Int4        `json:"weight"`
	Reps          int32              `json:"reps"`
	SetType       string             `json:"set_type"`
	ExerciseID    int32              `json:"exercise_id"`
	ExerciseName  string             `json:"exercise_name"`
	ExerciseOrder int32              `json:"exercise_order"`
	SetOrder      int32              `json:"set_order"`
	Volume        int32              `json:"volume"`
}

func (q *Queries) GetExerciseWithSets(ctx context.Context, arg GetExerciseWithSetsParams) ([]GetExerciseWithSetsRow, error) {
	rows, err := q.db.Query(ctx, getExerciseWithSets, arg.ExerciseID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExerciseWithSetsRow
	for rows.Next() {
		var i GetExerciseWithSetsRow
		if err := rows.Scan(
			&i.WorkoutID,
			&i.WorkoutDate,
			&i.WorkoutNotes,
			&i.SetID,
			&i.Weight,
			&i.Reps,
			&i.SetType,
			&i.ExerciseID,
			&i.ExerciseName,
			&i.ExerciseOrder,
			&i.SetOrder,
			&i.Volume,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrCreateExercise = `-- name: GetOrCreateExercise :one
INSERT INTO exercise (name, user_id) 
VALUES ($1, $2)
ON CONFLICT (user_id, name) DO UPDATE SET name = EXCLUDED.name
RETURNING id, name, created_at, updated_at, user_id
`

type GetOrCreateExerciseParams struct {
	Name   string `json:"name"`
	UserID string `json:"user_id"`
}

func (q *Queries) GetOrCreateExercise(ctx context.Context, arg GetOrCreateExerciseParams) (Exercise, error) {
	row := q.db.QueryRow(ctx, getOrCreateExercise, arg.Name, arg.UserID)
	var i Exercise
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
	)
	return i, err
}

const getRecentSetsForExercise = `-- name: GetRecentSetsForExercise :many
SELECT 
    s.id AS set_id,
    w.date AS workout_date,
    s.weight,
    s.reps,
    s.exercise_order,
    s.set_order,
    s.created_at
FROM "set" s
JOIN workout w ON w.id = s.workout_id
WHERE s.exercise_id = $1 AND s.user_id = $2
ORDER BY w.date DESC, s.exercise_order, s.set_order, s.created_at DESC
LIMIT 3
`

type GetRecentSetsForExerciseParams struct {
	ExerciseID int32  `json:"exercise_id"`
	UserID     string `json:"user_id"`
}

type GetRecentSetsForExerciseRow struct {
	SetID         int32              `json:"set_id"`
	WorkoutDate   pgtype.Timestamptz `json:"workout_date"`
	Weight        pgtype.Int4        `json:"weight"`
	Reps          int32              `json:"reps"`
	ExerciseOrder int32              `json:"exercise_order"`
	SetOrder      int32              `json:"set_order"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetRecentSetsForExercise(ctx context.Context, arg GetRecentSetsForExerciseParams) ([]GetRecentSetsForExerciseRow, error) {
	rows, err := q.db.Query(ctx, getRecentSetsForExercise, arg.ExerciseID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecentSetsForExerciseRow
	for rows.Next() {
		var i GetRecentSetsForExerciseRow
		if err := rows.Scan(
			&i.SetID,
			&i.WorkoutDate,
			&i.Weight,
			&i.Reps,
			&i.ExerciseOrder,
			&i.SetOrder,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSet = `-- name: GetSet :one
SELECT id, exercise_id, workout_id, weight, reps, set_type, created_at, updated_at, user_id, exercise_order, set_order FROM "set" 
WHERE id = $1 AND user_id = $2
`

type GetSetParams struct {
	ID     int32  `json:"id"`
	UserID string `json:"user_id"`
}

func (q *Queries) GetSet(ctx context.Context, arg GetSetParams) (Set, error) {
	row := q.db.QueryRow(ctx, getSet, arg.ID, arg.UserID)
	var i Set
	err := row.Scan(
		&i.ID,
		&i.ExerciseID,
		&i.WorkoutID,
		&i.Weight,
		&i.Reps,
		&i.SetType,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.ExerciseOrder,
		&i.SetOrder,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT id, user_id, created_at FROM users WHERE id = $1
`

// User queries
func (q *Queries) GetUser(ctx context.Context, id int32) (Users, error) {
	row := q.db.QueryRow(ctx, getUser, id)
	var i Users
	err := row.Scan(&i.ID, &i.UserID, &i.CreatedAt)
	return i, err
}

const getUserByUserID = `-- name: GetUserByUserID :one
SELECT id, user_id, created_at FROM users WHERE user_id = $1 LIMIT 1
`

func (q *Queries) GetUserByUserID(ctx context.Context, userID string) (Users, error) {
	row := q.db.QueryRow(ctx, getUserByUserID, userID)
	var i Users
	err := row.Scan(&i.ID, &i.UserID, &i.CreatedAt)
	return i, err
}

const getWorkout = `-- name: GetWorkout :one
SELECT id, date, notes, created_at, updated_at, user_id FROM workout WHERE id = $1 AND user_id = $2
`

type GetWorkoutParams struct {
	ID     int32  `json:"id"`
	UserID string `json:"user_id"`
}

// Basic SELECT queries
func (q *Queries) GetWorkout(ctx context.Context, arg GetWorkoutParams) (Workout, error) {
	row := q.db.QueryRow(ctx, getWorkout, arg.ID, arg.UserID)
	var i Workout
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
	)
	return i, err
}

const getWorkoutWithSets = `-- name: GetWorkoutWithSets :many
SELECT 
    w.id as workout_id,
    w.date as workout_date,
    w.notes as workout_notes,
    s.id as set_id,
    s.weight,
    s.reps,
    s.set_type,
    e.id as exercise_id,
    e.name as exercise_name,
    s.exercise_order,
    s.set_order,
    (COALESCE(s.weight, 0) * s.reps) as volume
FROM workout w
JOIN "set" s ON w.id = s.workout_id
JOIN exercise e ON s.exercise_id = e.id
WHERE w.id = $1 AND w.user_id = $2
ORDER BY s.exercise_order NULLS LAST, s.set_order NULLS LAST, s.id
`

type GetWorkoutWithSetsParams struct {
	ID     int32  `json:"id"`
	UserID string `json:"user_id"`
}

type GetWorkoutWithSetsRow struct {
	WorkoutID     int32              `json:"workout_id"`
	WorkoutDate   pgtype.Timestamptz `json:"workout_date"`
	WorkoutNotes  pgtype.Text        `json:"workout_notes"`
	SetID         int32              `json:"set_id"`
	Weight        pgtype.Int4        `json:"weight"`
	Reps          int32              `json:"reps"`
	SetType       string             `json:"set_type"`
	ExerciseID    int32              `json:"exercise_id"`
	ExerciseName  string             `json:"exercise_name"`
	ExerciseOrder int32              `json:"exercise_order"`
	SetOrder      int32              `json:"set_order"`
	Volume        int32              `json:"volume"`
}

// Complex queries for joining data
func (q *Queries) GetWorkoutWithSets(ctx context.Context, arg GetWorkoutWithSetsParams) ([]GetWorkoutWithSetsRow, error) {
	rows, err := q.db.Query(ctx, getWorkoutWithSets, arg.ID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWorkoutWithSetsRow
	for rows.Next() {
		var i GetWorkoutWithSetsRow
		if err := rows.Scan(
			&i.WorkoutID,
			&i.WorkoutDate,
			&i.WorkoutNotes,
			&i.SetID,
			&i.Weight,
			&i.Reps,
			&i.SetType,
			&i.ExerciseID,
			&i.ExerciseName,
			&i.ExerciseOrder,
			&i.SetOrder,
			&i.Volume,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExercises = `-- name: ListExercises :many
SELECT id, name, created_at, updated_at, user_id FROM exercise WHERE user_id = $1 ORDER BY name
`

func (q *Queries) ListExercises(ctx context.Context, userID string) ([]Exercise, error) {
	rows, err := q.db.Query(ctx, listExercises, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Exercise
	for rows.Next() {
		var i Exercise
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSets = `-- name: ListSets :many
SELECT id, exercise_id, workout_id, weight, reps, set_type, created_at, updated_at, user_id, exercise_order, set_order FROM "set" 
WHERE user_id = $1
ORDER BY exercise_order, set_order, id
`

func (q *Queries) ListSets(ctx context.Context, userID string) ([]Set, error) {
	rows, err := q.db.Query(ctx, listSets, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Set
	for rows.Next() {
		var i Set
		if err := rows.Scan(
			&i.ID,
			&i.ExerciseID,
			&i.WorkoutID,
			&i.Weight,
			&i.Reps,
			&i.SetType,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
			&i.ExerciseOrder,
			&i.SetOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkouts = `-- name: ListWorkouts :many
SELECT id, date, notes, created_at, updated_at, user_id FROM workout WHERE user_id = $1 ORDER BY date DESC
`

func (q *Queries) ListWorkouts(ctx context.Context, userID string) ([]Workout, error) {
	rows, err := q.db.Query(ctx, listWorkouts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Workout
	for rows.Next() {
		var i Workout
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSet = `-- name: UpdateSet :one
UPDATE "set" 
SET 
    weight = COALESCE($2, weight),
    reps = COALESCE($3, reps),
    set_type = COALESCE($4, set_type),
    updated_at = NOW()
WHERE id = $1 AND user_id = $5
RETURNING id, exercise_id, workout_id, weight, reps, set_type, created_at, updated_at, user_id, exercise_order, set_order
`

type UpdateSetParams struct {
	ID      int32       `json:"id"`
	Weight  pgtype.Int4 `json:"weight"`
	Reps    int32       `json:"reps"`
	SetType string      `json:"set_type"`
	UserID  string      `json:"user_id"`
}

func (q *Queries) UpdateSet(ctx context.Context, arg UpdateSetParams) (Set, error) {
	row := q.db.QueryRow(ctx, updateSet,
		arg.ID,
		arg.Weight,
		arg.Reps,
		arg.SetType,
		arg.UserID,
	)
	var i Set
	err := row.Scan(
		&i.ID,
		&i.ExerciseID,
		&i.WorkoutID,
		&i.Weight,
		&i.Reps,
		&i.SetType,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.ExerciseOrder,
		&i.SetOrder,
	)
	return i, err
}

const updateWorkout = `-- name: UpdateWorkout :one
UPDATE workout 
SET 
    date = COALESCE($2, date),
    notes = COALESCE($3, notes),
    updated_at = NOW()
WHERE id = $1 AND user_id = $4
RETURNING id, date, notes, created_at, updated_at, user_id
`

type UpdateWorkoutParams struct {
	ID     int32              `json:"id"`
	Date   pgtype.Timestamptz `json:"date"`
	Notes  pgtype.Text        `json:"notes"`
	UserID string             `json:"user_id"`
}

// UPDATE queries for PUT endpoint
func (q *Queries) UpdateWorkout(ctx context.Context, arg UpdateWorkoutParams) (Workout, error) {
	row := q.db.QueryRow(ctx, updateWorkout,
		arg.ID,
		arg.Date,
		arg.Notes,
		arg.UserID,
	)
	var i Workout
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
	)
	return i, err
}
